#!/usr/bin/env python

'''*******************MODULE DOCSTRING******************************************
ROS Node - IOT Action Client - Turtle
This module works as both Action Client and Simple Action Client and communucates
with the Simple Action Server(for turtle goals and results) and
Action Server(for MQTT and HTTP related goals and results)

Class: SimpleActionClientTurtle

Functions: start_callback, main, feedback_callback
*********************************************************************************'''
import rospy
import actionlib

from pkg_task1.msg import msgTurtleAction     # Message Class that is used by ROS Actions internally
from pkg_task1.msg import msgTurtleGoal       # Message Class that is used for Goal messages
from pkg_ros_iot_bridge.msg import msgRosIotAction  # Message Class that is used by
                                                        #ROS Actions internally
from pkg_ros_iot_bridge.msg import msgRosIotGoal    # Message Class that is used for Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotResult #Message class for handling Result Messages
from pkg_ros_iot_bridge.msg import msgMqttSub  #Message class that is used for
                                                #messages from MQTT Client

class SimpleActionClientTurtle(object):
    '''**********************CLASS DOCSTRING*************************
    Name: SimpleActionClientTurtle

    Class Variables: mqtt_sub_str

    Methods: send_goal, done_callback, on_transition, send_ac_goal
    *****************************************************************'''
    mqtt_sub_str = ''
    # Constructor
    def __init__(self):
        self._sac = actionlib.SimpleActionClient('/action_turtle',
                                                 msgTurtleAction)   #Works as Simple Action Client
        self._ac = actionlib.ActionClient('/action_ros_iot',
                                          msgRosIotAction)          #Works as Action Client
        self._sac.wait_for_server()
        rospy.loginfo("Simple Action server is up, we can send new goals!")
        self._goal_handles = {}
        self._config_mqtt_pub_topic = "eyrc/ArDiHiJi/ros_to_iot"
        self._ac.wait_for_server()
        rospy.loginfo("Action server up, we can send goals.")

    def send_goal(self, arg_dis, arg_angle):
        '''*************METHOD DOCSTRING**********************
        Name: send_goal

        Objective: To send the goal to Simple Action Server that drives the Turtle

        Arguments: arg_dis, arg_angle i.e goal distance and angle

        Returns: None
        ******************************************************

        * done_cb is set to the function pointer of the function which should be called once
            the Goal is processed by the Simple Action Server.

        * feedback_cb is set to the function pointer of the function which should be called while
            the goal is being processed by the Simple Action Server.'''
        # Creating Goal message for Simple Action Server
        goal = msgTurtleGoal(distance=arg_dis, angle=arg_angle)

        self._sac.send_goal(goal, done_cb=self.done_callback,
                            feedback_cb=feedback_callback)

        rospy.loginfo("Goal has been sent.")

    def done_callback(self, status, result):
        '''***************METHOD DOCSTRING*******************************
        Name: done_callback

        Objective: This function confirms that the goal has been reached
                    by printing the result and status on screen and publishes
                    the result to the MQTT pub topic that the MQTT client
                    is subscribing to

        Arguments: status,result i.e the status and result (pose of turtle)

        Returns: None
        *****************************************************************'''
        rospy.loginfo("Status is : " + str(status))
        rospy.loginfo("Result is : " + str(result))
        str_result = ('('+ str(result.final_x) + ',' + str(result.final_y) + ','
                      + str(result.final_theta)+')')
        goal_handle1 = self.send_ac_goal("mqtt", "pub", self._config_mqtt_pub_topic, str_result)
        self._goal_handles['1'] = goal_handle1

    def on_transition(self, goal_handle):
        '''**************************METHOD DOCSTRING**************************
        Name: on_transition

        Objective: This function processes the received goal from client and prints status
                    on screen

        Arguments: goal_handle from Action Client

        Returns: None
        ***********************************************************************'''

        # from on_goal() to on_transition(). goal_handle generated by send_goal() is used here.

        result = msgRosIotResult()

        index = 0
        for i in self._goal_handles:
            if self._goal_handles[i] == goal_handle:
                index = i
                break

        rospy.loginfo("Transition Callback. Client Goal Handle #: " + str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()))
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()))

        # Comm State - Monitors the State Machine of the Client which is different from Server's
        # Comm State = 2 -> Active
        # Comm State = 3 -> Wating for Result
        # Comm State = 7 -> Done

        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")

        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())

            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)

            if result.flag_success is True:
                rospy.loginfo("Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " + str(index))

    def send_ac_goal(self, arg_protocol, arg_mode, arg_topic, arg_message):
        '''********************METHOD DOCSTRING************
        Name: send_ac_goal

        Objective: to send Goals to Action Server

        Arguments: protocol (mqtt/http), mode (pub/sub),
                    topic and message

        Returns: goal_handle for the goal
        **************************************************'''
        # Creating a Goal Message object
        goal = msgRosIotGoal()

        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message
        rospy.loginfo("Send goal.")

        # self.on_transition - It is a function pointer to a function which will be called when
        #                       there is a change of state in the Action Client State Machine
        goal_handle = self._ac.send_goal(goal,
                                         self.on_transition,
                                         None)
        return goal_handle

def feedback_callback(feedback):
    '''**************************FUNCTION DOCSTRING**********************
    Name: feedback_callback

    Objective: to print feedback while Goal is being processed

    Arguements: feedback message

    Returns: None
    *********************************************************************'''
    rospy.loginfo(feedback)

def start_callback(msg):
    '''*******************FUNCTION DOCSTRING*********************
    Name: start_callback

    Objective: this function is used to check the message coming
                 from MQTT client for starting the turtle

    Arguments: msg i.e the message coming from MQTT client

    Returns: None
    *************************************************************'''
    SimpleActionClientTurtle.mqtt_sub_str = msg.message

def main():
    '''**********************FUNCTION DOCSTRING********************
    Name: main

    Objective: this is the driver function that initialize node,
                sends the goals through respective functions

    Arguments: None

    Returns: None
    ***************************************************************'''
    # Initializing ROS Node
    rospy.init_node('node_iot_action_client_turtle')

    # Creating an object for Simple Action Client.
    obj_client = SimpleActionClientTurtle()

    #Subscribing to topic /ros_iot_bridge/mqtt/sub for messages from MQTT Client and
    #waiting until 'start' message is received
    while SimpleActionClientTurtle.mqtt_sub_str != 'start':
        rospy.Subscriber('/ros_iot_bridge/mqtt/sub', msgMqttSub, start_callback)
    # Send Goals to Draw a Regular Hexagon
    obj_client.send_goal(2, 0)
    obj_client._sac.wait_for_result()

    obj_client.send_goal(2, 60)
    obj_client._sac.wait_for_result()

    obj_client.send_goal(2, 60)
    obj_client._sac.wait_for_result()

    obj_client.send_goal(2, 60)
    obj_client._sac.wait_for_result()

    obj_client.send_goal(2, 60)
    obj_client._sac.wait_for_result()

    obj_client.send_goal(2, 60)

    # Loop forever
    rospy.spin()

if __name__ == '__main__':
    main()
